# 42. Trapping Rain Water

**Difficulty:** Hard

---

Given n non-negative integers representing an elevation map where the width of
each bar is 1, compute how much water it can trap after raining.

---

## Example 1:

```
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
```

**Explanation:** The above elevation map (black section) is represented by array
[0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section)
are being trapped.

---

## Example 2:

```
Input: height = [4,2,0,3,2,5]
Output: 9
```

---

## Constraints:

- n == height.length
- 1 <= n <= 2 \* 10^4
- 0 <= height[i] <= 10^5

## Solution

Just reading this progam we can tell that we will need information about the
bounding walls that will hold water. There are a few ways where we can know this
information.

1. We could have a suffix and a prefix array that tell is the tallest bar behind
   us and after us. this could be accomplished by creating suffix and prefix
   arrays that hold this value. This brings us to our solution 1.

   ```python
   class Solution:
   def trap(self, height: List[int]) -> int:
       left = [0 for _ in range(len(height))]
       right = [0 for _ in range(len(height))]


       maxHeight = 0
       for i in range(len(height)):
           left[i] = maxHeight
           maxHeight = max(maxHeight, height[i])


       maxHeight = 0
       for i in range(len(height) - 1, -1, -1):
           right[i] = maxHeight
           maxHeight = max(maxHeight, height[i])


       maxWater = 0

       for i in range(len(height)):
           if left[i] != 0 and right[i] != 0:
               minbar =  min(left[i], right[i])
               if minbar > height[i]:
                   maxWater += abs(minbar - height[i])

       return maxWater
   ```

2. But we obviously want to do a better job right, here we are using space O(N).
   Lets look at the framing of our solution , we need to know of the prev taller
   bar and the next taller bar, often times, if what we want sounds like this
   "prev taller, next taller" the question breaks down to a monotonic stack
   problem. Heres how we would go about it.

   ```python
   class Solution:
       def trap(self, height: List[int]) -> int:

           stack = []
           total = 0


           for i, h in enumerate(height):
               while stack and stack[-1][1] < h:
                   ind, b = stack.pop()

                   if stack:
                       limit_h = min(h, stack[-1][1])
                       w = i - stack[-1][0] - 1
                       total += (limit_h - b) * (w)

               stack.append((i,h))

           return total
   ```
